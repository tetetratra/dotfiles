$1

未知のシステムや機能を認知科学に基づく7つの原則で体系的に調査し、理解しやすいドキュメントにまとめます。

注意：このコマンドは既存コードの動作を理解するためのものです。
新しい機能の設計や実装計画を立てるものではありません。
仕様書や要件定義書の作成も目的としていません。

例示のコードブロック内のコードブロックは、バッククォート2つで表現していいます。

## 目的

- 前提知識がない機能やシステムの全体像を把握する
- 階層的な情報提示、段階的な複雑さの導入など、認知科学の原則に基づいて調査する
- 調査結果を他のメンバーが理解しやすい形で記録する
- 必要に応じて特定処理の詳細フローまで深掘りする

## 出力物

このコマンドでは、以下の3つのカテゴリで出力を行います:

- **返答**: 作業完了の報告や調査結果の要約など、フロー型の出力（会話として返す）
- **成果物**: ドキュメントや整理結果など、ストック型の出力（後から参照できる形で返す）
  - 成果物の保存先について指示がある場合は、指定された箇所に書き込む
  - 指示がない場合は、通常のレスポンスとして返答の後に続けて出力する
- **作業**: システムへの変更や実行など、副作用を伴う作業

本コマンドの出力:

**返答**: 調査完了を報告する

**成果物**: 認知科学の7つの原則に基づく調査結果のドキュメントをレスポンスとして出力する

**作業**: なし

## 入力で確認すること

- 調査対象の機能やシステム（具体的な機能名、画面、API等）
- 調査の目的（なぜ調査するのか、何を知りたいのか）
- 既存のドキュメントや関連する調査結果（tmp/investigations/ 配下など）
- 調査の深さ（概要のみか、詳細な処理フローまで必要か）
- 情報が不足している場合は、着手前に質問を箇条書きする

## 調査手順

### 1. スコープ定義

- 調査対象を明確にする
- 調査のゴール（どこまで知れば十分か）を決める
- 既存ドキュメントの有無を確認

### 2. 7つの原則に基づく調査

**認知科学の7つの原則:**
1. 階層的な情報提示 - まず全体像・概要 → 次に詳細
2. 具体例と抽象概念の往復 - 抽象的な概念と具体例を併用
3. 視覚化と多様な表現形式 - 図、表、コード例などを活用
4. 段階的な複雑さの導入 - 簡単なバージョン → 徐々に詳細
5. 文脈と関連性の明示 - なぜ重要か、既知の知識との関連
6. 反復と要約 - 重要なポイントを複数回、異なる形で提示
7. インタラクティブな要素 - 理解度を確認する機会

**アプリケーション機能説明のステップ:**

以下の順序で情報を収集し、段階的に理解を深める（注: FAQは含めません。これは仕様書ではなく既存システムの理解・調査が目的のため）:

#### 2.1 概要・目的を調べる
**原則:** 階層的な情報提示、文脈と関連性の明示

- この機能は何をするものか（一言での説明）
- なぜこの機能が必要なのか（解決する課題）
- ステークホルダーごとのメリット
- 関連するファイル/モジュールの特定

#### 2.2 基本的な使い方を調べる
**原則:** 段階的な複雑さの導入（第一段階）

- 誰がこの機能を使うか（ユーザーロール）
- いつ使われるか（トリガー・タイミング）
- 基本的な操作フロー（最小限の知識で理解できる範囲）
- アクセス権限の制御方法

#### 2.3 詳細な機能を調べる
**原則:** 段階的な複雑さの導入（第二段階）、反復と要約

- この機能独自の用語・概念
- 設定可能なオプション
- 機能のバリエーション
- エッジケースや例外的な挙動

#### 2.4 具体的なユースケースを調べる
**原則:** 具体例と抽象概念の往復

- 実際の利用シーン（コード例やテストケースから）
- 典型的な使用パターン
- 他の機能との組み合わせ例
- 実装されている具体例の場所

#### 2.5 技術的な仕組みを調べる
**原則:** 視覚化と多様な表現形式、階層的な情報提示

技術的な仕組みを説明する際は、以下の形式で処理フローを記述:

- **技術スタック:** どのレイヤー、ライブラリ、外部サービスを使うか
- **エントリーポイント:** 処理の開始点を特定
- **処理フロー（コールスタック風）:**
  - 処理全体の流れを1-2文で導入する（「〜では...している」という形式）
  - 箇条書きリスト（番号なし）でネストを表現
  - 各ステップに以下を含める:
    - **クラス/メソッド名** (ファイルパス:行番号) ← 重要なポイントのみ記載
    - 処理内容を簡潔に説明する文
    - 最低限のコードブロック（クラス名、関数名、呼び出している関数のみ）
    - 積極的に `...` を使って省略
    - 閉じカッコ（`end`, `}` など）は無くても良い
    - 分岐が重要なロジックの場合のみ、最低限の分岐を記載
  - 分岐がある場合は ①②③ などのマーカーで順序を示す

例:

```
### 処理フロー（コールスタック風）

注文確認メール送信では、注文作成時にコールバックでメール送信ジョブをキューに登録し、バックグラウンドで実際のメール送信を行っています。

- **OrdersController#create** (app/controllers/orders_controller.rb:45)
  注文データを受け取り、Orderモデルを作成している。
  ``ruby
  class OrdersController
    def create
      ...
      @order.save  # after_create_commitコールバックが実行される
  ``

  - **Order#after_create_commit** (app/models/order.rb:23)
    注文作成後のコールバックで、メール送信ジョブをキューに登録している。

    ``ruby
    class Order
      after_create_commit :send_confirmation_email

      def send_confirmation_email
        OrderMailerJob.perform_later(id)
    ``

    - **OrderMailerJob#perform** (app/jobs/order_mailer_job.rb:8)
      バックグラウンドでメール送信処理を実行している。

      ``ruby
      class OrderMailerJob
        def perform(order_id)
          ...
          OrderMailer.confirmation_email(order).deliver_now
      ``

      - **OrderMailer#confirmation_email** (app/mailers/order_mailer.rb:12)
        注文確認メールのテンプレートを生成している。

        ``ruby
        class OrderMailer
          def confirmation_email(order)
            ...
            mail(to: @user.email, subject: "【注文確認】...")
        ``
```

- **データ構造:** 入力 → 変換 → 永続化 → 出力の流れ
- **主要な関連エンティティ（テーブル）:**
  - テーブルの情報として、関連するテーブルをインラインで記載
  - 外部キーによる参照を矢印（`→`）で示す
  - 例: 「Orderテーブル（注文情報を保存。user_id → Usersテーブルを参照）」
  - **注意:** テーブル・エンティティ関係図を別セクションとして切り出さない（認知負荷が高くなるため）

**⚠️ 避けるべき記述:**
- **コード構成の単なる列挙:** ファイル名とクラス名だけを羅列しても認知できません。各ファイルの「役割」と「なぜ必要か」を説明してください
- **取得ロジックなど細かいコードの羅列:** `find_by`, `where`, `includes`などの細かいクエリロジックを沢山書いても認知負荷が高いだけです。重要な処理フローのみに絞ってください
- **全てのメソッドの網羅的な説明:** 重要な処理フローに関わるメソッドのみを記載し、補助的なメソッドは省略してください

### 3. ドキュメント作成

理解しやすい資料作成のため、以下のポイントを適用:

**注意:** FAQやトラブルシューティングは含めません。このドキュメントは仕様書ではなく、既存システムの理解・調査が目的だからです。

#### 3.1 全体構成

**目次の追加:**
- ドキュメントの冒頭（機能名の直後）に、全セクションへのリンク付き目次を配置
- Markdownのリンク形式で各見出しにジャンプできるようにする
- 例:

```
# 注文確認メール機能

## 目次
- [概要・目的](#概要目的)
- [基本的な使い方](#基本的な使い方)
- [詳細な機能説明](#詳細な機能説明)
- [具体的なユースケース](#具体的なユースケース)
- [技術的な仕組み](#技術的な仕組み)
```

**セクション構成:**

以下の順序でセクションを構成（5ステップに沿った構成。FAQは含めません）:

**1. 概要・目的** - 「何をするものか」全体像
- **抽象:** この機能が解決する課題、提供する価値、ステークホルダーごとのメリットを説明
- **具体例:**
  - 「注文確認メール機能は、ユーザーが商品を購入した際に自動的に確認メールを送信する機能です」
  - 「なぜ必要か: 注文内容の確認と顧客への安心感を提供し、問い合わせを削減するため」
  - 「顧客のメリット: 注文内容をすぐに確認できる / 運営側のメリット: 手動確認の工数削減、顧客満足度向上」

**2. 基本的な使い方** - 「どう使うか」最小限の知識
- **抽象:** 誰がいつどのように使うか、基本的な操作フローを説明
- **具体例:**
  - 「ユーザーロール: 顧客（受信者）、管理者（テンプレート設定）」
  - 「トリガー: 注文完了時に自動送信 / 発送完了時に追加送信」
  - 「基本フロー: 1. 商品購入 → 2. 決済完了 → 3. 確認メール自動送信」

**3. 詳細な機能説明** - 「できることは何か」機能一覧
- **抽象:** この機能独自の用語・概念、設定可能なオプション、機能のバリエーションを説明
- **具体例:**
  - 「メールタイプ: order_confirmation（注文確認）、shipping_notification（発送通知）、delivery_complete（配達完了）など」
  - 「ステータス: queued（送信待ち）→ sending（送信中）→ sent（送信完了）」
  - 「オプション: 送信タイミングの調整、メールテンプレートの選択、添付ファイル（領収書PDF等）」

**4. 具体的なユースケース** - 「実際どう役立つか」実例
- **抽象:** 実際の利用シーン、典型的な使用パターン、他機能との組み合わせ例を説明
- **具体例:**
  - 「ユースケース1: 初回購入 - 注文完了直後に確認メールと会員登録完了メールを同時送信」
  - 「ユースケース2: 定期購入 - 次回発送予定日の3日前にリマインダーメールを自動送信」
  - 「組み合わせ: ポイント付与機能と連携して、付与ポイント数をメールに記載」

**5. 技術的な仕組み** - 「どう動いているか」内部構造
- **抽象:** 技術スタック、処理フロー、データ構造、コード構成を説明
- **具体例:**
  - 「技術スタック: Sidekiq（非同期処理）、SendGrid（メール送信）、Liquid（テンプレートエンジン）」
  - 「処理フロー: 注文確認メール送信では、注文作成時にコールバックでメール送信ジョブをキューに登録し、バックグラウンドで実際のメール送信を行っています」

```ruby
- **OrdersController#create** (app/controllers/orders_controller.rb:45)
  注文データを受け取り、Orderモデルを作成
  ``ruby
  class OrdersController
    def create
      ...
      @order.save  # after_create_commitコールバックが実行される
  ``
  - **Order#after_create_commit** (app/models/order.rb:23)
    注文作成後のコールバックで、メール送信ジョブをキューに登録
    ``ruby
    class Order
      after_create_commit :send_confirmation_email

      def send_confirmation_email
        OrderMailerJob.perform_later(id)
    ``
    - **OrderMailerJob#perform** (app/jobs/order_mailer_job.rb:8)
      バックグラウンドでメール送信処理を実行 (非同期処理)
      ``ruby
      class OrderMailerJob
        def perform(order_id)
          ...
          OrderMailer.confirmation_email(order).deliver_now
      ``
      - **OrderMailer#confirmation_email** (app/mailers/order_mailer.rb:12)
        注文確認メールのテンプレートを生成
        ``ruby
        class OrderMailer
          def confirmation_email(order)
            ...
            mail(to: @user.email, subject: "【注文確認】...")
        ``
```

  - 「主要な関連エンティティ: Orderテーブル（注文情報を保存。user_id → Usersテーブルを参照）、EmailLogテーブル（送信履歴を記録。order_id → Ordersテーブルを参照）、EmailTemplateテーブル（メールテンプレートを管理）」
  - 「データ構造: 注文作成 → メール送信ジョブ登録 → テンプレートレンダリング → SendGrid送信 → ログ保存」

**注意:** FAQやトラブルシューティングの項目は含めません。これは仕様書ではなく、既存システムの調査・理解のためのドキュメントだからです。

#### 3.2 認知負荷を減らす工夫
- 各セクションの冒頭に「このセクションで分かること」を明記する
- セクション間に遷移文を入れる
  ```
  ここまでで○○が分かりました。
  (まとめの1〜2文)
  次は△△を見ていきます。
  ```
- 📌マーカーで要約ボックスを配置
- 複雑な説明の前に「ざっくり言うと」を追加
- **正確な説明の後に「つまりどういうこと？」を追加:**
  - 技術的な説明や複雑な概念の後に、平易な言葉で言い換える
  - 例:
    ```
    STI（Single Table Inheritance）は、複数のモデルを1つのテーブルで管理する設計パターンです。
    type カラムでモデルを区別し、各モデルは共通の属性を継承します。

    **つまりどういうこと？**
    メールタイプごとにテーブルを分けず、1つのテーブルで全タイプを管理する仕組みです。
    ```

#### 3.3 視覚的階層化
- ビジュアルマーカーで情報を分類:
  - ⚠️ 重要な注意事項
  - 💡 キーポイント
  - 📝 技術的詳細
  - 🎯 核心的な概念
- コードブロックには「以下のコードは『○○する処理』です」と目的を明記

#### 3.4 文体の統一
- すべての文章をですます調で統一
- 箇条書きの末尾に「。」をつけない
- 複雑な熟語を使わず平易な日本語で説明
- 一文が長すぎる場合は適宜改行・分割

### 4. 品質チェック

#### 4.1 内容チェック
- [ ] 機能に関する記憶をまっ更な状態でリセット
- [ ] 文書を上から読み直す
- [ ] 説明の無い概念が唐突に出てきていないかチェック
- [ ] 各セクションで「何を学ぶか」が明示されているか
- [ ] セクション間の繋がりが分かるか（遷移文があるか）

#### 4.2 情報の絞り込み
- [ ] 再度読み返し、本当に重要な情報のみを残す
- [ ] 以下の不要な情報を削除:
  - コードを読めばすぐに意味や内容がわかるもの
  - 枝葉の情報
  - 名前から機能を類推できるもの
  - 一般的な技術用語の説明（この機能独自の用語のみ記載）

#### 4.3 完了の判断基準
以下の質問に答えられれば、調査完了:
- [ ] この機能を一言で説明できる（概要・目的）
- [ ] なぜこの機能が必要か説明できる（概要・目的）
- [ ] 基本的な使い方を説明できる（基本的な使い方）
- [ ] 詳細な機能や用語を説明できる（詳細な機能説明）
- [ ] 具体的なユースケースを示せる（具体的なユースケース）
- [ ] 技術的な仕組みを説明できる（技術的な仕組み）
- [ ] 実装・保守に必要な詳細情報が揃っている

**注意:** FAQやトラブルシューティングは含めません。これは仕様書ではなく既存システムの調査ドキュメントのためです。

## 出力テンプレート

基本的なマークダウン構造（詳細は「3.1 全体構成」を参照）:

```
# （機能名）

## 目次
- [概要・目的](#概要目的)
- [基本的な使い方](#基本的な使い方)
- [詳細な機能説明](#詳細な機能説明)
- [具体的なユースケース](#具体的なユースケース)
- [技術的な仕組み](#技術的な仕組み)

## 📖 概要・目的
**このセクションで分かること:** ...

（内容）

**📌 要約:** ...

---

（遷移文）

---

## 📖 基本的な使い方
**このセクションで分かること:** ...

（内容）

---

（遷移文）

---

## 📖 詳細な機能説明
**このセクションで分かること:** ...

（内容）

**📌 要約:** ...

---

（遷移文）

---

## 📖 具体的なユースケース
**このセクションで分かること:** ...

（内容）

**📌 要約:** ...

---

（遷移文）

---

## 📖 技術的な仕組み
**このセクションで分かること:** ...

### 技術スタック
（使用している技術）

### 処理フロー（コールスタック風）

（処理全体の流れを1-2文で導入。「〜では...している」という形式）

- **クラス名/メソッド名** (ファイルパス:行番号)
  （処理内容を簡潔に説明）
  ``言語名
  class クラス名
    def メソッド名
      ...
      next_method()  # 重要な呼び出し
  ``

  - **次のクラス/メソッド名** (ファイルパス:行番号)
    （処理内容を簡潔に説明）
    ``言語名
    class 次のクラス名
      def 次のメソッド名
        ...
        another_method()
    ``

    - **さらに次のクラス/メソッド名** (ファイルパス:行番号)
      [非同期処理] （処理内容を簡潔に説明）
      ``言語名
      class さらに次のクラス名
        def さらに次のメソッド名
          ...
          final_method()
      ``

**つまりどういうこと？**
（処理フローを平易な言葉で言い換え）

### 主要な関連テーブル

（テーブル情報をインラインで記載。例: 「Orderテーブル（注文情報を保存。user_id → Usersテーブルを参照）」）

**注意:** テーブル・エンティティ関係図を別セクションとして切り出さないでください。

### データ構造

（入力 → 変換 → 永続化 → 出力の流れ）

```

## チェックポイント

最終的なドキュメントが以下を満たしているか確認:

### 全体構成
- [ ] ドキュメントの冒頭に目次が配置されているか
- [ ] 目次の各項目が対応する見出しにリンクされているか
- [ ] 調査対象とその目的が明確に記載されているか
- [ ] すべてのセクション（概要・目的、基本的な使い方、詳細な機能説明、具体的なユースケース、技術的な仕組み）すべてが揃っているか
- [ ] FAQセクションが含まれていないか（仕様書ではなく調査ドキュメントのため不要）
- [ ] 各セクションが認知科学の原則に基づいているか（階層的提示、段階的な複雑さ導入、具体例と抽象概念の往復など）

### 認知負荷を減らす工夫
- [ ] 各セクションで「何を学ぶか」が明示されているか
- [ ] セクション間の繋がりが分かる（遷移文がある）
- [ ] 重要なポイントが要約されている（📌マーカー）
- [ ] 視覚的に情報の重要度が区別できる（⚠️💡📝🎯マーカー）
- [ ] 正確な説明の後に「つまりどういうこと？」で平易な言い換えがあるか

### 具体性と詳細度
- [ ] 具体的なユースケースが含まれているか
- [ ] コードブロックに文脈説明がある
- [ ] 処理フローがコールスタック風（箇条書きリスト＋最低限のコードブロック）に記述されているか
- [ ] 処理全体の流れを導入する文（「〜では...している」形式）があるか
- [ ] 重要なポイントにファイルパスと行番号が含まれているか
- [ ] 各ステップに最低限のコードブロック（クラス名、関数名、呼び出している関数のみ）が含まれているか
- [ ] コードで `...` を積極的に使って省略しているか
- [ ] 非同期処理などの特徴的な処理は `[非同期処理]` のように注釈が明記されているか
- [ ] データの変換や状態変化が明示されているか
- [ ] テーブル情報がインラインで記載されているか（別セクションとして切り出していないか）
- [ ] 外部キー参照が矢印（→）で示されているか
- [ ] 拡張・カスタマイズの方法が説明されているか

### 避けるべき記述（認知負荷の高い記述）
- [ ] コード構成の単なる列挙をしていないか（ファイル名とクラス名だけの羅列）
- [ ] 取得ロジックなど細かいコードを沢山書いていないか（find_by, where, includesなど）
- [ ] 全てのメソッドを網羅的に説明していないか（重要な処理フローのみに絞る）
- [ ] テーブル・エンティティ関係図を別セクションとして切り出していないか（インラインで記載する）
- [ ] コードブロックで詳細な処理を書きすぎていないか（クラス名、関数名、呼び出している関数のみに絞る）

### 情報の質
- [ ] 専門用語は最初に平易な説明がある
- [ ] 不要な情報（コードを読めば分かる情報、一般的な技術用語の説明）が削除されているか
- [ ] 他のメンバーが読んで理解できる内容か

## 核心原則

**認知科学に基づく7つの原則を適用する:**
1. 階層的な情報提示 - 全体像から詳細へ
2. 具体例と抽象概念の往復 - ユースケースとコード例を活用
3. 視覚化と多様な表現形式 - 表、マーカー、コード例を使用
4. 段階的な複雑さの導入 - 基本 → 詳細 → 技術
5. 文脈と関連性の明示 - 各セクションの意図を明記
6. 反復と要約 - 📌マーカーで繰り返し強調
7. インタラクティブな要素 - 「つまりどういうこと？」で理解度を確認

**読者の体験:**
読者の頭の中で「今どこにいて、次に何が来るか、それはなぜか」が常に明確な状態を保つこと
