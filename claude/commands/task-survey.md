$1

未知のシステムや機能を認知科学に基づく7つの原則で体系的に調査し、理解しやすいドキュメントにまとめます。

注意：このコマンドは既存コードの動作を理解するためのものです。
新しい機能の設計や実装計画を立てるものではありません。
仕様書や要件定義書の作成も目的としていません。

## 目的

- 前提知識がない機能やシステムの全体像を把握する
- 階層的な情報提示、段階的な複雑さの導入など、認知科学の原則に基づいて調査する
- 調査結果を他のメンバーが理解しやすい形で記録する
- 必要に応じて特定処理の詳細フローまで深掘りする

## 出力物

このコマンドでは、以下の3つのカテゴリで出力を行います:

- **返答**: 作業完了の報告や調査結果の要約など、フロー型の出力（会話として返す）
- **成果物**: ドキュメントや整理結果など、ストック型の出力（後から参照できる形で返す）
  - 成果物の保存先について指示がある場合は、指定された箇所に書き込む
  - 指示がない場合は、通常のレスポンスとして返答の後に続けて出力する
- **作業**: システムへの変更や実行など、副作用を伴う作業

本コマンドの出力:

**返答**: 調査完了を報告する

**成果物**: 認知科学の7つの原則に基づく調査結果のドキュメントをレスポンスとして出力する

**作業**: なし

## 入力で確認すること

- 調査対象の機能やシステム（具体的な機能名、画面、API等）
- 調査の目的（なぜ調査するのか、何を知りたいのか）
- 既存のドキュメントや関連する調査結果（tmp/investigations/ 配下など）
- 調査の深さ（概要のみか、詳細な処理フローまで必要か）
- 情報が不足している場合は、着手前に質問を箇条書きする

## 調査手順

### 1. スコープ定義

- 調査対象を明確にする
- 調査のゴール（どこまで知れば十分か）を決める
- 既存ドキュメントの有無を確認

### 2. 7つの原則に基づく調査

**認知科学の7つの原則:**
1. 階層的な情報提示 - まず全体像・概要 → 次に詳細
2. 具体例と抽象概念の往復 - 抽象的な概念と具体例を併用
3. 視覚化と多様な表現形式 - 図、表、コード例などを活用
4. 段階的な複雑さの導入 - 簡単なバージョン → 徐々に詳細
5. 文脈と関連性の明示 - なぜ重要か、既知の知識との関連
6. 反復と要約 - 重要なポイントを複数回、異なる形で提示
7. インタラクティブな要素 - 理解度を確認する機会

**アプリケーション機能説明の7ステップ:**

以下の順序で情報を収集し、段階的に理解を深める:

#### 2.1 概要・目的を調べる
**原則:** 階層的な情報提示、文脈と関連性の明示

- この機能は何をするものか（一言での説明）
- なぜこの機能が必要なのか（解決する課題）
- ステークホルダーごとのメリット
- 関連するファイル/モジュールの特定

#### 2.2 基本的な使い方を調べる
**原則:** 段階的な複雑さの導入（第一段階）

- 誰がこの機能を使うか（ユーザーロール）
- いつ使われるか（トリガー・タイミング）
- 基本的な操作フロー（最小限の知識で理解できる範囲）
- アクセス権限の制御方法

#### 2.3 詳細な機能を調べる
**原則:** 段階的な複雑さの導入（第二段階）、反復と要約

- この機能独自の用語・概念
- 設定可能なオプション
- 機能のバリエーション
- エッジケースや例外的な挙動

#### 2.4 具体的なユースケースを調べる
**原則:** 具体例と抽象概念の往復

- 実際の利用シーン（コード例やテストケースから）
- 典型的な使用パターン
- 他の機能との組み合わせ例
- 実装されている具体例の場所

#### 2.5 技術的な仕組みを調べる
**原則:** 視覚化と多様な表現形式、階層的な情報提示

技術的な仕組みを説明する際は、以下の形式で処理フローを記述:

- **技術スタック:** どのレイヤー、ライブラリ、外部サービスを使うか
- **エントリーポイント:** 処理の開始点を特定
- **処理フロー（コールスタック風）:**
  - 各関数/メソッド呼び出しを番号付きリストで記述
  - インデント（ネスト）で呼び出し階層を表現
  - 各ステップで以下を記録:
    - クラス/メソッド名とファイルパス（行番号も含める）
      - Rubyの場合、例: `OrdersController#create (app/controllers/orders_controller.rb:45)` のような形式
    - 主要な処理内容
    - データの変換や状態変化
    - 外部サービスやDBへのアクセス
  - 非同期処理は `[非同期]` を明記
  - コードブロックではなく、通常のリスト形式で記載する
  - 例:
    - メソッドA (ファイル名:行番号)
       - 処理内容
       - メソッドB (ファイル名:行番号)
          - 処理内容
          - メソッドC (ファイル名:行番号)
             - 処理内容
       - メソッドD (ファイル名:行番号)
          - 処理内容
- **テーブル・エンティティ関係図の検討:**
  - 関連するテーブルが複数ある場合、関係図を作成する
  - ツリー形式でテーブル間の関係を表現
  - 外部キーによる参照を矢印（`→`）で示す
  - 例:
    ```
    orders (注文)
      ├─ id
      ├─ user_id → users (顧客)
      └─ status

    email_logs (送信ログ)
      ├─ id
      ├─ order_id → orders
      └─ sent_at
    ```
- **データ構造:** 入力 → 変換 → 永続化 → 出力の流れ
- **コード構成:** 関連ファイルとその役割

#### 2.6 応用・カスタマイズ方法を調べる
**原則:** 段階的な複雑さの導入（発展段階）

- 拡張ポイント（フック、プラグイン機構など）
- カスタマイズ可能な箇所
- 類似機能との違い
- 将来の拡張の可能性

#### 2.7 FAQ・トラブルシューティングを調べる
**原則:** 反復と要約、インタラクティブな要素

- よくある疑問とその回答
- 重要な注意事項
- 想定と異なる挙動
- 改善の余地がある箇所

### 3. ドキュメント作成

理解しやすい資料作成のため、以下のポイントを適用:

#### 3.1 全体構成

**目次の追加:**
- ドキュメントの冒頭（機能名の直後）に、全セクションへのリンク付き目次を配置
- Markdownのリンク形式で各見出しにジャンプできるようにする
- 例:
  ```markdown
  # 注文確認メール機能

  ## 目次
  - [概要・目的](#概要目的)
  - [基本的な使い方](#基本的な使い方)
  - [詳細な機能説明](#詳細な機能説明)
  - [具体的なユースケース](#具体的なユースケース)
  - [技術的な仕組み](#技術的な仕組み)
  - [応用・カスタマイズ](#応用カスタマイズ)
  - [FAQ・トラブルシューティング](#faqトラブルシューティング)
  ```

**セクション構成:**

以下の順序でセクションを構成（7ステップに沿った構成）:

**1. 概要・目的** - 「何をするものか」全体像
- **抽象:** この機能が解決する課題、提供する価値、ステークホルダーごとのメリットを説明
- **具体例:**
  - 「注文確認メール機能は、ユーザーが商品を購入した際に自動的に確認メールを送信する機能です」
  - 「なぜ必要か: 注文内容の確認と顧客への安心感を提供し、問い合わせを削減するため」
  - 「顧客のメリット: 注文内容をすぐに確認できる / 運営側のメリット: 手動確認の工数削減、顧客満足度向上」

**2. 基本的な使い方** - 「どう使うか」最小限の知識
- **抽象:** 誰がいつどのように使うか、基本的な操作フローを説明
- **具体例:**
  - 「ユーザーロール: 顧客（受信者）、管理者（テンプレート設定）」
  - 「トリガー: 注文完了時に自動送信 / 発送完了時に追加送信」
  - 「基本フロー: 1. 商品購入 → 2. 決済完了 → 3. 確認メール自動送信」

**3. 詳細な機能説明** - 「できることは何か」機能一覧
- **抽象:** この機能独自の用語・概念、設定可能なオプション、機能のバリエーションを説明
- **具体例:**
  - 「メールタイプ: order_confirmation（注文確認）、shipping_notification（発送通知）、delivery_complete（配達完了）など」
  - 「ステータス: queued（送信待ち）→ sending（送信中）→ sent（送信完了）」
  - 「オプション: 送信タイミングの調整、メールテンプレートの選択、添付ファイル（領収書PDF等）」

**4. 具体的なユースケース** - 「実際どう役立つか」実例
- **抽象:** 実際の利用シーン、典型的な使用パターン、他機能との組み合わせ例を説明
- **具体例:**
  - 「ユースケース1: 初回購入 - 注文完了直後に確認メールと会員登録完了メールを同時送信」
  - 「ユースケース2: 定期購入 - 次回発送予定日の3日前にリマインダーメールを自動送信」
  - 「組み合わせ: ポイント付与機能と連携して、付与ポイント数をメールに記載」

**5. 技術的な仕組み** - 「どう動いているか」内部構造
- **抽象:** 技術スタック、処理フロー、データ構造、コード構成を説明
- **具体例:**
  - 「技術スタック: Sidekiq（非同期処理）、SendGrid（メール送信）、Liquid（テンプレートエンジン）」
  - 「処理フロー（コールスタック風）:」
    ```
    - OrdersController#create (app/controllers/orders_controller.rb:45)
       - 注文データを受け取り、Orderモデルを作成
       - Order#after_create_commit (app/models/order.rb:23)
          - 注文作成後のコールバック
          - OrderMailer.confirmation_email(order.id).deliver_later (app/mailers/order_mailer.rb:12)
             - メール送信ジョブをSidekiqキューに登録
             - [非同期] OrderMailerJob#perform (app/jobs/order_mailer_job.rb:8)
                - Sidekiqワーカーがジョブを実行
                - EmailTemplate#render (app/models/email_template.rb:34)
                   - Liquidテンプレートをレンダリング
                   - 注文データを埋め込む
                - SendGridService.send_email (app/services/sendgrid_service.rb:19)
                   - SendGrid APIを呼び出してメール送信
                   - 送信ログをemail_logsテーブルに記録
    ```
  - 「テーブル・エンティティ関係図:」
    ```
    orders (注文)
      ├─ id
      ├─ user_id → users (顧客)
      └─ status

    email_logs (送信ログ)
      ├─ id
      ├─ order_id → orders
      ├─ email_type
      └─ sent_at

    email_templates (テンプレート)
      ├─ id
      ├─ name
      └─ content
    ```
  - 「主要クラス: OrderMailer（メーラー）、EmailTemplate（テンプレート）、EmailDeliveryService（送信処理）」

**6. 応用・カスタマイズ** - 「どう拡張するか」発展
- **抽象:** 拡張ポイント、カスタマイズ例、類似機能との違い、将来の拡張可能性を説明
- **具体例:**
  - 「拡張ポイント: 新しいメールタイプの追加（継承）、カスタムテンプレートの作成、多言語対応」
  - 「類似機能との違い: マーケティングメールは一斉配信 / トランザクションメールは個別イベント駆動」
  - 「将来の拡張: SMS通知、LINE通知、プッシュ通知への対応」

**7. FAQ・トラブルシューティング** - よくある疑問と解決策
- **抽象:** よくある質問、重要な注意事項、想定と異なる挙動、改善の余地を説明
- **具体例:**
  - 「Q: メールが届かない → A: 迷惑メールフォルダを確認 / 配信ログでエラーを確認」
  - 「注意: 一度送信したメールは取り消し不可 / 同一注文に対して重複送信はされない」
  - 「改善の余地: 送信失敗時の自動リトライ機能が未実装」

#### 3.2 認知負荷を減らす工夫
- 各セクションの冒頭に以下を記載:
  - 📖 このセクションで分かること
  - 🎯 読むべき人
  - ⏱️ 読了時間（概算）
- セクション間に遷移文を入れる
  ```
  ここまでで○○が分かりました。
  (まとめの1〜2文)
  次は△△を見ていきます。
  ```
- 📌マーカーで要約ボックスを配置
- 複雑な説明の前に「ざっくり言うと」を追加
- **正確な説明の後に「つまりどういうこと？」を追加:**
  - 技術的な説明や複雑な概念の後に、平易な言葉で言い換える
  - 例:
    ```
    STI（Single Table Inheritance）は、複数のモデルを1つのテーブルで管理する設計パターンです。
    type カラムでモデルを区別し、各モデルは共通の属性を継承します。

    **つまりどういうこと？**
    メールタイプごとにテーブルを分けず、1つのテーブルで全タイプを管理する仕組みです。
    ```

#### 3.3 視覚的階層化
- ビジュアルマーカーで情報を分類:
  - ⚠️ 重要な注意事項
  - 💡 キーポイント
  - 📝 技術的詳細
  - 🎯 核心的な概念
- コードブロックには「以下のコードは『○○する処理』です」と目的を明記

#### 3.4 文体の統一
- すべての文章をですます調で統一
- 箇条書きの末尾に「。」をつけない
- 複雑な熟語を使わず平易な日本語で説明
- 一文が長すぎる場合は適宜改行・分割

### 4. 品質チェック

#### 4.1 内容チェック
- [ ] 機能に関する記憶をまっ更な状態でリセット
- [ ] 文書を上から読み直す
- [ ] 説明の無い概念が唐突に出てきていないかチェック
- [ ] 各セクションで「何を学ぶか」が明示されているか
- [ ] セクション間の繋がりが分かるか（遷移文があるか）

#### 4.2 情報の絞り込み
- [ ] 再度読み返し、本当に重要な情報のみを残す
- [ ] 以下の不要な情報を削除:
  - コードを読めばすぐに意味や内容がわかるもの
  - 枝葉の情報
  - 名前から機能を類推できるもの
  - 一般的な技術用語の説明（この機能独自の用語のみ記載）

#### 4.3 完了の判断基準
以下の質問に答えられれば、調査完了（7ステップすべてをカバー）:
- [ ] この機能を一言で説明できる（概要・目的）
- [ ] なぜこの機能が必要か説明できる（概要・目的）
- [ ] 基本的な使い方を説明できる（基本的な使い方）
- [ ] 詳細な機能や用語を説明できる（詳細な機能説明）
- [ ] 具体的なユースケースを示せる（具体的なユースケース）
- [ ] 技術的な仕組みを説明できる（技術的な仕組み）
- [ ] 拡張方法や応用を説明できる（応用・カスタマイズ）
- [ ] よくある質問や注意点を列挙できる（FAQ・トラブルシューティング）
- [ ] 実装・保守に必要な詳細情報が揃っている

## 出力テンプレート

基本的なマークダウン構造（詳細は「3.1 全体構成」を参照）:

```markdown
# （機能名）

## 目次
- [概要・目的](#概要目的)
- [基本的な使い方](#基本的な使い方)
- [詳細な機能説明](#詳細な機能説明)
- [具体的なユースケース](#具体的なユースケース)
- [技術的な仕組み](#技術的な仕組み)
- [応用・カスタマイズ](#応用カスタマイズ)
- [FAQ・トラブルシューティング](#faqトラブルシューティング)

## 📖 概要・目的
**このセクションで分かること:** ...
**読むべき人:** ...
**読了時間:** ...

（内容）

**📌 要約:** ...

---
（遷移文）
---

## 📖 基本的な使い方
**このセクションで分かること:** ...
**読むべき人:** ...
**読了時間:** ...

（内容）

---
（遷移文）
---

## 📖 詳細な機能説明
**このセクションで分かること:** ...
**読むべき人:** ...
**読了時間:** ...

（内容）

**📌 要約:** ...

---
（遷移文）
---

## 📖 具体的なユースケース
**このセクションで分かること:** ...
**読むべき人:** ...
**読了時間:** ...

（内容）

**📌 要約:** ...

---
（遷移文）
---

## 📖 技術的な仕組み
**このセクションで分かること:** ...
**読むべき人:** ...
**読了時間:** ...

### 技術スタック
（使用している技術）

### 処理フロー（コールスタック風）

**ざっくり言うと:**
（処理の流れを1-2文で説明）

**詳細フロー:**
``
1. （処理） (ファイルパス:行番号)
   - （処理内容）
   2. （処理） (ファイルパス:行番号)
      - （処理内容）
      3. （処理） (ファイルパス:行番号)
         - （処理内容）
   4. [非同期] （処理） (ファイルパス:行番号)
      - （処理内容）
``

**つまりどういうこと？**
（処理フローを平易な言葉で言い換え）

**📌 フロー要約:** ...

### テーブル・エンティティ関係図

（関連するテーブルが複数ある場合）

``
table_name (説明)
  ├─ column1
  ├─ column2 ───→ related_table (関連)
  └─ column3
``

（その他の技術詳細）

---
（遷移文）
---

## 📖 応用・カスタマイズ
**このセクションで分かること:** ...
**読むべき人:** ...
**読了時間:** ...

（内容）

**📌 要約:** ...

---
（遷移文）
---

## 📖 FAQ・トラブルシューティング
**このセクションで分かること:** ...
**読むべき人:** ...
**読了時間:** ...

**Q: （質問）**
A: （回答）

---

⚠️ **（注意事項）**

📝 **（発見事項）**
```

## チェックポイント

最終的なドキュメントが以下を満たしているか確認:

### 全体構成（7ステップ）
- [ ] ドキュメントの冒頭に目次が配置されているか
- [ ] 目次の各項目が対応する見出しにリンクされているか
- [ ] 調査対象とその目的が明確に記載されているか
- [ ] 7つのセクション（概要・目的、基本的な使い方、詳細な機能説明、具体的なユースケース、技術的な仕組み、応用・カスタマイズ、FAQ）すべてが揃っているか
- [ ] 各セクションが認知科学の原則に基づいているか（階層的提示、段階的な複雑さ導入、具体例と抽象概念の往復など）

### 認知負荷を減らす工夫
- [ ] 各セクションで「何を学ぶか」が明示されているか
- [ ] セクション間の繋がりが分かる（遷移文がある）
- [ ] 重要なポイントが要約されている（📌マーカー）
- [ ] 視覚的に情報の重要度が区別できる（⚠️💡📝🎯マーカー）
- [ ] 読者が自分に必要な部分を判断できる（対象読者の明示）
- [ ] 正確な説明の後に「つまりどういうこと？」で平易な言い換えがあるか

### 具体性と詳細度
- [ ] 具体的なユースケースが含まれているか
- [ ] コードブロックに文脈説明がある
- [ ] 処理フローがコールスタック風（番号付きリスト＋インデント）に記述されているか
- [ ] 各ステップにファイルパスと行番号が含まれているか
- [ ] 非同期処理が `[非同期]` で明記されているか
- [ ] データの変換や状態変化が明示されているか
- [ ] 関連するテーブルが複数ある場合、テーブル・エンティティ関係図が含まれているか
- [ ] 関係図で外部キー参照が矢印で示されているか
- [ ] 拡張・カスタマイズの方法が説明されているか

### 情報の質
- [ ] 専門用語は最初に平易な説明がある
- [ ] 不要な情報（コードを読めば分かる情報、一般的な技術用語の説明）が削除されているか
- [ ] 他のメンバーが読んで理解できる内容か

## 核心原則

**認知科学に基づく7つの原則を適用する:**
1. 階層的な情報提示 - 全体像から詳細へ
2. 具体例と抽象概念の往復 - ユースケースとコード例を活用
3. 視覚化と多様な表現形式 - 表、マーカー、コード例を使用
4. 段階的な複雑さの導入 - 基本 → 詳細 → 技術 → 応用
5. 文脈と関連性の明示 - 各セクションの意図を明記
6. 反復と要約 - 📌マーカーで繰り返し強調
7. インタラクティブな要素 - FAQ で理解度を確認

**読者の体験:**
読者の頭の中で「今どこにいて、次に何が来るか、それはなぜか」が常に明確な状態を保つこと
