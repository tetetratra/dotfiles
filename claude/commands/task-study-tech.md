$ARGUMENTS

これから導入・実装する技術や概念について、前提知識・関連知識を収集・整理し、ユーザーの理解を促します。

## 目的

- これから導入する技術について「それは何か」「なぜ使うのか」「どう使うのか」を理解する
- 専門用語や前提知識を先回りして解説する
- 因果関係を明確にし、「なぜそれが必要か」の根拠を示す
- 実装着手可能なレベルまで疑問を解消する

## 入力で確認すること

- 対象タスクの内容（何を導入・実装するのか）
- 既に分かっている情報・既知の技術
- 調査の深さ（どこまで掘り下げるか）
- 情報が不足している場合は、着手前に質問を箇条書きする

## 手順

### 大方針

1. **連想ツリーを広げる**: タスクから疑問を列挙
2. **答えを調査・整理する**: 各疑問に答え、因果関係を明確にする
3. **再帰**: 答えから新たな疑問が生まれたら、1に戻る
4. **終了判定**: 実装着手可能なレベルまで掘り下げたら整理して出力

### 「連想ツリーを広げる」の具体的方法

1. **技術キーワードの抽出**
   - タスク文から技術・ツール・概念を抽出
   - 例: "今はunicornを使っているけれど、pumaと比較した上でpitchforkの方がよければ乗り換えたい" → "unicorn", "puma", "pitchfork", "アプリケーションサーバー", "Reforking", "マルチスレッド", "マルチプロセス"

2. **各キーワードについて疑問を生成**
   - **What**: それは何か？
   - **Why**: なぜ使うのか？なぜ必要か？
   - **How**: どう使うのか？どう導入するのか？

3. **Howから派生する疑問を生成**
   - 手順の中で出てくる専門用語
   - 前提条件（権限、トークン、設定など）
   - ファイル・ディレクトリの場所

4. **具体的な疑問形式にする**
   - ❌ 抽象的: "トークンとは？"
   - ⭐ 具体的: "なぜトークンが必要？" "どうやって作る？" "どの権限が必要？"

### 「答えを調査・整理する」の具体的方法

1. **情報源の優先順位**
   - 公式ドキュメント（最優先）
   - 社内リポジトリの事例（Grep/Glob）
   - 信頼できる技術記事・ブログ（WebSearch）
   - GitHub公式リポジトリのexample

2. **答えの記載方法**
   - 簡潔に（2〜3文）
   - 詳細は公式ドキュメントへリンク
   - コード例があれば短く引用

3. **因果関係を明確にする（重要）**
   - 「〜が必要」と述べる場合、必ず「なぜ必要か」の根拠を示す
   - 因果の連鎖を追える形で記述する
   - 例:
     ```
     ❌ 悪い例: PitchforkはReforkingによりメモリ効率が改善する

     ⭐ 良い例:
     - Rubyアプリケーションはリクエスト処理によってメモリを遅延ロードする
     - 初期化時のforkでは、まだロードされていないメモリが多い
     - リクエスト処理後にメモリへの書き込みが発生すると、Copy-on-Writeが働き、メモリが各プロセスに複製される
     - よって、初期化時のforkではCoW効率が時間とともに低下する
     - Reforkingでは、既に「温まった」ワーカーからforkするため、共有メモリが増える
     - 結果として、メモリ使用量が約30%削減される
     ```

4. **新たな疑問の抽出**
   - 答えの中で登場した専門用語
   - 「〜が必要」という記述 → 「なぜ必要？」「どうやって準備？」
   - これらを疑問ツリーに追加して次のサイクルへ

### 終了条件

以下のいずれかを満たしたら終了：
- 実装に着手できるレベルまで疑問が解消された
- 3〜5階層程度まで掘り下げた
- すべての疑問に根拠のある答えが得られた

## 具体的な調査プロセスの例

**タスク**: 「今はunicornを使っているけれど、pumaと比較した上でpitchforkの方がよければ乗り換えたい」

### 第1サイクル: 初期の疑問を広げる

#### 連想ツリーを広げる（第1階層）
- unicorn、puma、pitchforkとは何か？
- それぞれの違いは？
- なぜ乗り換えを検討するのか？
- どのような基準で選ぶべきか？

#### 答えを調査・整理する
1. **unicorn、puma、pitchforkとは何か？**
   - WebSearch調査 → いずれもRubyのアプリケーションサーバー
   - Unicorn: マルチプロセスアーキテクチャ、スロークライアント対応にリバースプロキシが必要
   - Puma: マルチスレッド + マルチプロセス、Rails 6以降のデフォルト
   - Pitchfork: ShopifyがUnicornをベースに開発、Reforking機能が特徴
   - **新たな疑問**: Reforking機能とは？アーキテクチャの違いによる影響は？

2. **それぞれの違いは？**
   - アーキテクチャ: Unicorn（マルチプロセス）、Puma（マルチスレッド + マルチプロセス）、Pitchfork（マルチプロセス + Reforking）
   - メモリ効率: Unicorn（CoW利用）、Puma（スレッドベース）、Pitchfork（Reforkingで約30%削減）
   - **新たな疑問**: スレッドセーフとは？選択基準は？

3. **なぜ乗り換えを検討するのか？**
   - 一般的な理由: メモリ削減、パフォーマンス改善、Rails新バージョン対応、スロークライアント対応
   - **新たな疑問**: 具体的な効果は？デメリットは？

4. **どのような基準で選ぶべきか？**
   - 判断基準が不明確
   - **新たな疑問**: それぞれを選ぶべきケースは？

### 第2サイクル: 新たな疑問を広げる

#### 連想ツリーを広げる（第2階層）
- Reforkingの詳細な仕組みは？なぜメモリ効率が改善するのか？
- マルチスレッドとマルチプロセスの違いによる影響は？
- スレッドセーフとは？Pumaで注意すべきことは？
- それぞれの選択基準は？
- 具体的なメモリ削減・パフォーマンス改善の効果は？
- 移行のデメリットや注意点は？

#### 答えを調査・整理する
1. **Reforkingの詳細な仕組みは？なぜメモリ効率が改善するのか？**
   - 仕組み: 通常のpreforkingは初期化時にfork、Reforkingは一定リクエスト処理後に「温まった」ワーカーを新テンプレートとしてfork
   - なぜメモリ効率が改善するのか（因果関係）:
     - Rubyアプリケーションはリクエスト処理によってメモリを遅延ロード
     - 初期化時のforkでは、まだロードされていないメモリが多い
     - リクエスト処理後にメモリへの書き込みが発生すると、Copy-on-Writeが働き、メモリが各プロセスに複製される
     - よって、初期化時のforkではCoW効率が時間とともに低下する
     - Reforkingでは、既に「温まった」ワーカーからforkするため、共有メモリが増える
     - 結果として、メモリ使用量が約30%削減される
   - **新たな疑問**: なし

2. **マルチスレッドとマルチプロセスの違いによる影響は？**
   - マルチプロセス: メモリ空間が独立、スレッドセーフ不要、GVL影響なし
   - マルチスレッド: メモリ共有で効率的、スレッドセーフ必須、I/O待機時に他スレッド実行可能
   - **新たな疑問**: なし

3. **スレッドセーフとは？Pumaで注意すべきことは？**
   - スレッドセーフ: マルチスレッド処理で各スレッドが互いに影響し合わない性質
   - Pumaで注意すべきこと: 全てのgemとアプリケーションコードがスレッドセーフである必要
   - なぜ注意が必要か（因果関係）:
     - Pumaはマルチスレッドで動作する
     - 複数のスレッドが同じインスタンス変数にアクセスする可能性がある
     - スレッドセーフでないコードは、予期しない動作やデータ破損を引き起こす
     - よって、Pumaを使う場合はスレッドセーフな実装が必須
   - **新たな疑問**: なし

4. **それぞれの選択基準は？**
   - Unicorn: スレッドセーフでないアプリケーション、内部向け
   - Puma: Rails 5以降の新規、I/O待機が多い、メモリ限定環境
   - Pitchfork: 大規模モノリス、メモリ劇的削減、週数回デプロイ、コンテナ環境
   - **新たな疑問**: 移行のデメリットや具体的な注意点は？

5. **具体的なメモリ削減・パフォーマンス改善の効果は？**
   - Shopifyの事例（Pitchfork）: メモリ約30%削減、レイテンシー約9%改善
   - Pumaへの移行事例: メモリ880MB→600MB、GitLab.comで40%削減
   - **新たな疑問**: なし

6. **移行のデメリットや注意点は？**
   - Pumaへの移行: マルチスレッドの複雑性、全gemのスレッドセーフ検証、設定の複雑さ、メモリ増加の可能性
   - Pitchforkへの移行: フォークセーフの複雑性、機能削減、Linux 3.4以上必要、依存関係の精査
   - なぜこれらの注意が必要か:
     - Pitchforkはプロセスが複数回forkされる
     - 通常のpreforkingサーバーで動作するアプリケーションでも、Pitchforkでは問題が出る可能性
     - よって、スタックを完全に理解し、依存関係を精査できる必要がある
   - **新たな疑問**: 具体的な移行手順は？

### 第3サイクル: さらに掘り下げる

#### 連想ツリーを広げる（第3階層）
- 具体的な移行手順は？（Unicorn→Puma、Unicorn→Pitchfork）
- 移行時の設定ファイルの変更は？
- 移行後の動作確認方法は？

#### 答えを調査・整理する
1. **具体的な移行手順は？**
   - Unicorn→Pumaの移行: Gemfile変更、config/puma.rb作成、設定対応付け、スレッドセーフ確認、段階的ロールアウト
   - Unicorn→Pitchforkの移行: Gemfile変更、設定ファイル変更、Reforking設定追加、フォークセーフ確認、開発環境テスト、段階的ロールアウト
   - **新たな疑問**: なし

2. **移行時の設定ファイルの変更は？**
   - Unicorn→Pumaの設定対応: `worker_processes` → `workers`、`preload_app true` → `preload_app!`、`after_fork` → `on_worker_boot`
   - Pitchforkの設定例: `worker_processes`、`timeout`、`before_fork`、`after_mold_fork`（Refork時）
   - **新たな疑問**: なし

3. **移行後の動作確認方法は？**
   - メモリ使用量の監視、レイテンシーの計測、エラーログの確認、スレッドセーフ問題の検出、段階的なトラフィック移行
   - **新たな疑問**: なし

### 終了判定
✅ すべての疑問に因果関係を持った答えが得られた
✅ 実装に必要な情報が揃った
✅ 3階層まで掘り下げた
→ 整理して出力

## 成果物例

(コードブロック内のコードブロックはバッククォート2個で囲っています)

```
## 前提知識・関連知識

- unicorn、puma、pitchforkとは？
  - いずれもRubyのアプリケーションサーバー（Rackアプリケーション用のHTTPサーバー）

  - **Unicorn**
    - マルチプロセスアーキテクチャ
    - スロークライアント対応にNginxなどのリバースプロキシが必要
    - 古くから使われている実績のあるサーバー

  - **Puma**
    - マルチスレッド + マルチプロセス（クラスタリング）対応
    - Rails 6以降のデフォルトアプリケーションサーバー（参考：https://scoutapm.com/blog/which-ruby-app-server-is-right-for-you-ja）
    - スロークライアント対応が組み込まれている

  - **Pitchfork**
    - ShopifyがUnicorn 6.1.0をベースに開発（参考：https://github.com/Shopify/pitchfork）
    - マルチプロセスアーキテクチャ
    - Reforking機能が最大の特徴

- アーキテクチャの違いとその影響
  - **Unicorn**：マルチプロセスのみ
    - プロセス間はメモリ空間が独立
    - スレッドセーフを気にする必要がない
    - Copy-on-Writeを利用するが、時間経過でメモリ共有が減少

  - **Puma**：マルチスレッド + マルチプロセス
    - プロセス内でメモリを共有
    - スレッドベースのため、プロセスあたりのメモリは少ない
    - なぜスレッドセーフが必要か？
      - Pumaはマルチスレッドで動作する
      - 複数のスレッドが同じインスタンス変数にアクセスする可能性がある
      - スレッドセーフでないコードは、予期しない動作やデータ破損を引き起こす
      - よって、Pumaを使う場合は全てのgemとアプリケーションコードがスレッドセーフである必要
    - RubyのGVL（Global VM Lock）により、同時に実行されるスレッドは常に1つ
    - I/O待機時に他のスレッドが実行できるため、I/O boundなアプリケーションで有利

  - **Pitchfork**：マルチプロセス + Reforking
    - Reforking機能により継続的に高いCopy-on-Write効率を維持
    - スレッドセーフを気にする必要がない

- Pitchforkの Reforking 機能とは？
  - **通常のpreforking**：初期化時に親プロセスから子プロセスをfork
  - **Reforking**：一定のリクエスト処理後、最も最適化されたワーカーを新しいテンプレートとして昇格させ、そこから新しいワーカーをfork

  - なぜメモリ効率が改善するのか？（因果関係）
    - Rubyアプリケーションはリクエスト処理によってメモリを遅延ロード（lazy load）する
    - 初期化時のforkでは、まだロードされていないメモリが多い
    - リクエスト処理後にメモリへの書き込みが発生すると、Copy-on-Writeが働き、メモリが各プロセスに複製される
    - よって、初期化時のforkではCoW効率が時間とともに低下する
    - Reforkingでは、既に「温まった」ワーカーからforkするため、共有メモリが増える
    - 結果として、メモリ使用量が約30%削減される（参考：https://railsatscale.com/2023-10-23-pitchfork-impact-on-shopify-monolith/）

- 具体的なパフォーマンス・メモリ改善効果
  - **Shopifyの事例（Pitchfork）**：（参考：https://railsatscale.com/2023-10-23-pitchfork-impact-on-shopify-monolith/）
    - メモリ使用量：約30%削減（デプロイが少ない週末は10-12%）
    - レイテンシー：約9%改善（週末は14%）
    - 36ワーカー構成で128MiBのメモリ割り当てが4.6GiBから最小限の増加に削減

  - **Pumaへの移行事例**：
    - メモリ使用量：880MB→600MB程度に削減
    - GitLab.comでは40%のメモリ削減（参考：https://scoutapm.com/blog/which-ruby-app-server-is-right-for-you-ja）

- 選択基準
  - **Unicornを選ぶべきケース**：
    - スレッドセーフでないアプリケーション
    - 低速なクライアントの影響を受けず、かつ内部向けのアプリケーション（リバースプロキシ前提）

  - **Pumaを選ぶべきケース**：
    - Rails 5以降の新規アプリケーション（デフォルト）
    - I/O待機が多いアプリケーション
      - なぜ？
        - PumaはマルチスレッドでI/O wait時に別スレッドの処理を進められる
        - よって、I/O boundなアプリケーションで効率が良い
    - メモリリソースが限られている環境
    - スロークライアントへの対応が必要

  - **Pitchforkを選ぶべきケース**：
    - 大規模なRailsモノリス
    - メモリ使用量を劇的に削減したい
    - デプロイ頻度が週に数回程度（効果が最大化される）
    - フォークセーフな実装を確保できる
    - コンテナ化された環境（デーモン化不要）

- 移行のデメリットと注意点
  - **Pumaへの移行**：
    - マルチスレッドの複雑性：想定外の動作が発生する可能性
    - 全てのgemがスレッドセーフである必要がある
      - なぜ？
        - Pumaはマルチスレッドで動作する
        - スレッドセーフでないgemは競合状態やデータ破損を引き起こす
        - よって、全ての依存gemの検証が必要
    - 設定の複雑さ：bind、pidfile、state_pathの適切な設定が必要
    - メモリ増加の可能性：デフォルト16スレッドではUnicornより多くなる場合も
    - PumaWorkerKillerなどでワーカーの定期再起動が必要な場合がある

  - **Pitchforkへの移行**：
    - フォークセーフの複雑性：間違いが重大なバグをもたらす可能性
      - なぜ？
        - Pitchforkはプロセスが複数回forkされる
        - コネクション継承やバックグラウンドスレッドが問題を引き起こす可能性
        - よって、依存関係の精査とフォークセーフの確保が必須
    - 機能削減：デーモン化、pidファイル管理、ホットリロードが削除されている
      - なぜ削除された？
        - コンテナ化された環境を前提としているため
        - シンプルな設計を重視するため
    - Linux 3.4以上が必要（PR_SET_CHILD_SUBREAPER機能）
    - 段階的な導入が推奨：まず開発環境で十分にテスト

- 移行手順
  - **Unicorn→Pumaの移行**：
    1. Gemfileの変更：`gem 'unicorn'`を`gem 'puma'`に変更
    2. 設定ファイルの作成：`config/puma.rb`を作成
    3. 設定の対応付け：
       ``
       # Unicorn (config/unicorn.rb)
       worker_processes 3
       preload_app true
       after_fork do |server, worker|
         ActiveRecord::Base.establish_connection
       end

       # Puma (config/puma.rb)
       workers 3
       preload_app!
       on_worker_boot do
         ActiveRecord::Base.establish_connection
       end
       ``
    4. スレッドセーフの確認：全てのgemとアプリケーションコードを検証
    5. 段階的なロールアウト

  - **Unicorn→Pitchforkの移行**：
    1. Gemfileの変更：`gem 'unicorn'`を`gem 'pitchfork'`に変更
    2. 設定ファイルの変更：`config/unicorn.rb`を`config/pitchfork.rb`に
    3. Unicornと互換性が高いため、多くの設定はそのまま使用可能
    4. Reforking設定の追加（オプション）：
       ``
       # config/pitchfork.rb
       worker_processes ENV.fetch("WEBSERVER_WORKERS", 2).to_i
       timeout 10
       before_fork do |server|
         # データベース接続を切断
       end
       after_mold_fork do |server, mold|
         # Refork時の処理
       end
       ``
    5. フォークセーフの確認：依存関係の精査が重要
    6. 開発環境で十分にテスト
    7. 段階的な本番環境へのロールアウト

- 判断のためのチェックリスト
  - 現在のアプリケーションの問題は？
    - メモリ不足？ → Pitchforkを検討
    - レスポンスの遅延？ → Pumaを検討（I/O boundの場合）
    - 特に問題なし？ → 移行不要

  - アプリケーションの特性は？
    - スレッドセーフか？
      - Yes → Pumaの選択肢あり
      - No → Unicorn/Pitchfork
    - I/O待機が多いか？
      - Yes → Pumaが有利
      - No → Unicorn/Pitchfork

  - 運用環境は？
    - コンテナ化されているか？ → Pitchfork向き
    - デプロイ頻度は？
      - 週に数回 → Pitchforkの効果大
      - 1日に複数回 → Pitchforkの効果小

  - リソースと体制は？
    - 全ての依存gemを精査できるか？ → 精査できればPuma/Pitchforkの選択肢
    - 段階的なテストとロールアウトが可能か？ → 可能であれば移行推奨

## 参考情報
- 公式ドキュメント：
  - Pitchfork GitHub: https://github.com/Shopify/pitchfork
  - Shopify Pitchfork impact: https://railsatscale.com/2023-10-23-pitchfork-impact-on-shopify-monolith/
  - Rails threading guide: https://railsguides.jp/threading_and_code_execution.html
- 比較記事：
  - Unicorn vs Puma vs Passenger: https://scoutapm.com/blog/which-ruby-app-server-is-right-for-you-ja
  - Puma/Unicorn/Passenger最適化設定: https://techracho.bpsinc.jp/hachi8833/2022_06_14/47696
- 移行事例：
  - UnicornからPumaへの移行: https://parrot.hatenadiary.jp/entry/2018/07/27/162939
  - STORESのPitchfork導入: https://product.st.inc/entry/introduce-pitchfork
```

## チェックポイント

全体：
- [ ] タスクから技術キーワードを正しく抽出できているか
- [ ] すべての疑問に答えが得られているか
- [ ] 実装着手可能なレベルまで掘り下げたか
- [ ] ネストリスト形式で出力されているか

因果関係：
- [ ] 「〜が必要」に対して「なぜ必要か」の根拠が示されているか
- [ ] 因果の連鎖が追える形になっているか
- [ ] 専門用語に対する説明があるか

情報源：
- [ ] 公式ドキュメントへのリンクが含まれているか
- [ ] 社内の参考事例が検索されているか
- [ ] 信頼できる情報源から調査しているか

返答：
- [ ] 調査完了を報告しているか
- [ ] 成果物として調査結果をレスポンスとして出力しているか
